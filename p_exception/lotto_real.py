# 실제 로또 규칙

# 1~45 까지의 번호 중 무작위 6개로 이루어진 리스트가 추첨 한 번
# 한 번의 추첨 내에서는 중복되는 숫자가 없으며, 번호는 오름차순으로 정렬됨

# 당첨 번호는 1~45 까지의 중복 없는 무작위 숫자 7개
# 당첨 번호는 오름차순 정렬을 따로 하지 않음
# 그리고 당첨 번호의 마지막(7번째)은 보너스 숫자로 취급

# 내 추첨 한 번과 당첨 번호를 비교해서 몇 개 맞혔는지를 계산하고
# 각 추첨 별 맞힌 개수를 리스트에 담아서 출력
# 그리고 그 결과에 따라 아래 조건 중 가장 높은 등수가 출력
'''
    1등: 6개 번호 전부 일치
    2등: 보너스 번호 일치 + 나머지 번호 중 5개 일치
    3등: 보너스 번호 제외한 나머지 번호 중 5개 일치
    4등: 보너스 번호 제외한 나머지 번호 중 4개 일치
    5등: 보너스 번호 제외한 나머지 번호 중 3개 일치

    일치 개수 2개 이하면 낙첨
'''

# 위 규칙대로 만든 여러 번의 추첨(리스트)으로 이루어진 최종 추첨 리스트... 를 만들어주는 함수를 만들 것
# 단, 추첨 횟수는 사용자 입력에 따라 설정
# 그리고 예외 상황 발생 시(숫자 말고 다른 걸 입력한다던가...), exception으로 처리

# 출력은 당첨 번호 리스트 먼저 보여주고,
# 내가 추첨한 번호 리스트를 그 다음에 보여줌 - 각 리스트가 끝날 때마다 줄바꿈
# 그 밑에 맞힌 개수로 이루어진 리스트를 출력하고
# 마지막에 가장 높은 등수를 출력

# 목표: 함수 구현
# 나중에는 클래스랑 모듈화도...?
# + 오늘(1/12) git 배웠으니 수정 사항 생길 때마다 Github에 올리기

# 무작위 추첨 기능을 만들기 위한 random 라이브러리 import
import random


# 로또 추첨 함수
def lotto_draw(num: int):
    # 각 추첨 별 당첨 횟수를 기록하기 위한 리스트 생성
    result = []
    
    # 당첨 번호 생성 - 마지막 번호는 보너스 번호로 쓸 예정
    # 중복 검사 로직은 컴프리헨션 말고 다른 방법으로?
    # 그렇다면 당첨 번호 저장할 list 역시 초기에는 빈 list로 생성
    win_num = []
    
    # 당첨 번호 생성하면서 중복 검사
    # 숫자는 7개지만 중복되는 값은 추가하지 않으니, 결국 몇 번 반복할 지는 모름 - while문 사용
    # win_num의 길이가 7이 되면 = 숫자 7개가 채워지면 반복 종료
    while len(win_num) < 7:
        # 일단 1~45 중 랜덤 숫자를 ran_num 변수에 할당
        ran_num = random.randint(1, 45)
        
        # 만약 ran_num 이 win_num(당첨 번호) 리스트에 없다면 해당 번호 추가
        # 만약 기존에 win_num 있던 번호라면 append만 실행 안 하면 되니, else나 continue는 쓰지 않음
        if ran_num not in win_num:
            win_num.append(ran_num)
            
    # 당첨 번호 리스트가 랜덤으로, 중복 없이 잘 나오는지 테스트
    # 리스트 안 숫자는 7개 고정이므로, 슬라이싱 할 때 인덱스 번호에 -1 같은 거 쓸 필요 없을 듯
    print(f'당첨 번호: {win_num[0:6]}   보너스 번호: {win_num[6]}')

    # 내 추첨번호 생성 - 1~45 까지의 숫자 중, 중복 없는 7개짜리 번호로 이루어진 리스트 num개
    # 초기에는 리스트 안에 리스트 num개(함수 입력값)로 만들고
    my_draw = [[] for el in range(num)]

    # 전체 리스트의 각 인덱스를 돌면서 - for i in range(len(my_draw))
    # 각 인덱스 안 리스트(추첨 결과 num개)마다 위에서 썼던 while문으로 랜덤 숫자 넣으면서 중복 검사
    # 단, while문 반복이 끝나고, 다음 for문 반복이 시작되기 전에 방금 채운 리스트 오름차순으로 정렬
    for i in range(len(my_draw)):
        # my_draw의 i번(0 ~ 입력값-1) 인덱스에 숫자 6개가 채워질 때까지 무한 반복
        while len(my_draw[i]) < 6:
            # 이하 while 반복문 안 로직은 당첨 번호 로직과 동일
            ran_draw = random.randint(1, 45)

            if ran_draw not in my_draw[i]:
                my_draw[i].append(ran_draw)

        # while문 반복이 끝날 때마다 = 숫자 6개로 이루어진 리스트 하나가 완성될 때마다
        # 오름차순 정렬 실행(.sort()) - 해당 리스트를 직접 수정하는 메소드
        my_draw[i].sort()

    # '내 추첨 번호' 텍스트 먼저 출력하고
    print(f'내 추첨 번호')

    # 이후, 각 줄에 내 추첨 번호로 이루어진 리스트 하나씩 출력
    for i in range(len(my_draw)):
        print(my_draw[i])

    # 각 추첨 별 맞힌 개수를 list로 만들기
    # 그리고 보너스 번호(win_num[6]) 맞힌 것도 기록해야 되는데...
    # 그러면 각 추첨마다 {일치: n개, 보너스: (0 or 1)개} 식으로 딕셔너리로 만들어야 되나?

    # 위에서 만든 list(result 변수)에 각 추첨에 대한 결과 넣기
    # 내 추첨의 각 인덱스(추첨 1회에 대한 리스트) 순회
    for k in range(len(my_draw)):
        # 맞힌 개수와 보너스 일치 여부(0 or 1) 저장할 변수 초기화
        correct_count = 0
        bonus = 0

        # 추가로 1회 추첨 리스트의 각 번호도 순회
        for number in range(len(my_draw[k])):

            # 추첨 번호가 당첨 번호 리스트(win_num[0:6]) 안에 있는지 확인
            if number in win_num[0:6]:
                # 있다면 맞힌 개수 +1
                correct_count += 1

            # 만약 보너스 번호가 일치하면
            if number == win_num[6]:
                # 보너스 +1
                bonus += 1

        # 결과 리스트에 넣을 결과(dict) 생성
        result_formatting = {'일치' : f'{correct_count}개', '보너스': f'{"일치" if bonus == 1 else "불일치"}'}

        # 위에서 만든 dict를 result의 각 인덱스에 추가
        result.append(result_formatting)

    print('\n결과')

    for i in range(len(result)):
        print(result[i])

# 1/12 저장 - 당첨 번호, 보너스 번호, 내 추첨 번호는 제대로 출력되나, 결과 출력은 보완 필요


# 함수 실행 - 안에 print 있으니, 여기서 따로 안 써도 됨
lotto_draw(3)
